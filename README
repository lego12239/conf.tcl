OVERVIEW
========

conf package is pure-tcl package for loading a textual configuration data from
file, channels and strings. It supports conf syntax with hierarchical and
ini-style sections and key-value pairs where value can be string or list.
The features are:

* conf syntax: hierarchical sections support
* conf syntax: ini-style sections support
* conf syntax: comments support
* conf syntax: file inclusion support
* callback based parsing: callback is called on every key-value assignment,
  section change and file inclusion

conf package contains 3 main routines for text configuration file loading:
* conf::load_from_file - to load a conf from a file
* conf::load_from_fh - to load a conf from an open file handler
* conf::load_from_str - to load a conf from a string

And the next utility routines:
* conf::escape_value - escape a specified value according to conf syntax rules


SYNOPSIS
========

  load_from_file ?-hd STR? ?-path STR? CALLBACK FILE_NAME
  load_from_fh ?-hd STR? ?-path STR? CALLBACK CHAN
  load_from_str ?-hd STR? ?-path STR? CALLBACK
                ?-s START_INDEX? ?-e END_INDEX? CONF_STR
  escape_value VALUE


DESCRIPTION
===========

  load_from_file command parse a specified file and calls a specified callback
  on every parsed key-value, section start/end and file inclusion.
  This command accepts the next options:
  -hd STR
      use STR as hierarchy delimiter in key names and group names.
      By default, there is no hierarchy delimiter.
  -path STR
      use STR as file path prefix for every included file.
      By default, "./".

  And 2 mandatory arguments:
  CALLBACK
      CALLBACK is a proc name or a list - {CALLBACK ARG1 ...}. This callback
      is called on every parsed key-value, section enter/leave and
      file inclusion.
  FILE
      A file name to parse.

  load_from_fh works like a load_from_file proc and accepts the same options,
  but parse a data from a specified file handle(chan) instead of file
  specified by a name.

  load_from_str command parse a data from a specified string and
  calls a specified callback like a load_from_file proc.
  Options are the same as for load_from_file with addition of:
  -s START_INDEX
      start parsing of a string from specified position(in chars)
  -e END_INDEX
      end parsing of a string at specified position(in chars); this will be
      the last character we read

  escape_value command returns an escaped form(according to conf syntax
  rules) of specified value.


CONF SYNTAX
===========

Conf consists from key-value pairs, which can be grouped in sections.
Whitespaces are ignored. Comment can be started by # symbols at almost any
place(excluding # inside a quoted string) and lasts until the end of the
line.

Key, value and section name can consist of any chars exclude any space
chars, '=', '#', '"', '[', ']', '{', '}', '+', '?'. If a key, value or
section name contains any of these characters, then the entire key, value
or section name must be enclosed in double quotes. In this case, if double
quotes appears inside the value, it must be escaped with a backslash(\).

Value can be a string(quoted or not) or a list. A list is started with '['
and is ended with ']'. List elements are separated with spaces. Each element
of a list is a string or a list.

Key, section and file inclusion must start on new line.


ASSIGNMENT
----------

Assignment a string to a key:

k1 = some_word
k2 = "some string \"with\" spaces"

Assignment a list to a key:

k1 = [v1 v2 v3]
k2 = [v1 "some string \"with\" spaces" v2]

Assignment a list of lists to a key:

k3 = [[v1 v2] [v3 v4] [v5 v6]]

Also, ?= and += can be used for assignment:

k1 ?= some_word
k2 ?= [v1 v2]

k3 = v1
k3 += some_word
k3 += [v2 v3]

?= can be used to assign a value only if this key isn't defined yet.
And += can be used to append a value to existent one.


FILE INCLUDING
--------------

Conf file can include another conf files with syntax:

< FILENAME

Where FILENAME is glob pattern. Files are parsed in alphabetical order.


SECTIONS
--------

A section can be defined in two ways. With [] syntax:

[SECT_NAME]

Or with {} syntax:

SECT_NAME {
}

If a section is defined with `[SECT_NAME]` syntax, then current section
prefix(top of a section prefixes stack) is replaced with SECT_NAME. If a
section is defined with `SECT_NAME {` syntax, then SECT_NAME section
prefix is pushed to a section prefixes stack and becomes a current section
prefix until we reach corresponding "}", in which case SECT_NAME is poped
from a section prefixes stack and previous value becomes a top of a stack
and a current section prefix. In other words, []-sections is not
stacked and is replaced by both []-section and {}-section that come after
it; {}-sections is stacked and both []-section and {}-section coming
after is appended to it. E.g. if we call any of load proc with "-hd .",
then this confs are equal:

variant 1:

sect1.sect2.key1 = val1
sect1.sect2.key2 = val2
sect1.sect2.sect3.key3 = val3
sect1.sect2.key4 = val4

variant 2:

[sect1.sect2]
key1 = val1
key2 = val2
sect3.key3 = val3
key4 = val4

variant 3:

[sect1.sect2]
key1 = val1
key2 = val2
[sect1.sect2.sect3]
key3 = val3
[sect1.sect2]
key4 = val4

variant 4:

sect1.sect2 {
	key1 = val1
	key2 = val2
	sect3 {
		key3 = val3
	}
	key4 = val4
}

variant 5:

sect1.sect2 {
	key1 = val1
	key2 = val2
	key4 = val4
	[sect3]
	key3 = val3
}


CONF SYNTAX ABNF
================

conf = (key-value / section / include-stmt / WSP0)
       *(NL (key-value / section / include-stmt / WSP0))
key-value = key ("=" / "+=" / "?=") (value / list)
key = word / str
value = word / str
list = WSP0 "[" *((word / str / list) WSP) "]"
section = ("[" (word / str) "]" *conf) /
        ((word / str) "{" *conf "}")
include-stmt = "<" WSP0 (word / str)
word = WSP0 (%d33 / %d36-60 / %d62-90 / %d92 / %d94-122 / %d124 / %d126 - %d255) WSP0
        ; all except WSP, =, #, ",
        ; +, ?, [, ], {, }
str = WSP0 DQUOTE (%d01-d91 / %93-d255 / %d92 %d92 / %d92 DQUOTE) DQUOTE WSP0
        ; any chars in double quotes, where double quotes inside string
        ; can be escaped with \ char
WSP0 = *WSP
WSP = SP / HTAB / NL
NL = CR / LF / CRLF


CALLBACK
========

Callback is a proc name or a list with proc name and args like
{PROC ARG1 ARG2 ...}. This callback is called on every parsed key-value,
section enter/leave and file inclusion. It is called with specified arguments
and appended context variable name, the operation, a full key name, a value.
E.g. if callback is specified as {cb_proc privvar}, then callback must be
define as:

proc cb_proc {privvarname _ctx op kname kval} {
	upvar #0 $privvarname privvar
	upvar $_ctx ctx

...
}

Callback last parameters must be:
  - ctx var name (parser internal structure, mostly you needn't it)
  - operation (=S, =L, +=S, +=L, ?=S, ?=L, SECT_CH or FILE)
  - key full name (list with a sect name and a key name)
  - value

Where operation is:
- "=S" for assigning a string (e.g. k1 = v1)
- "=L" for assigning a list (e.g. k1 = [v1 v2])
- "+=S" for adding a string (e.g. k1 += v1)
- "+=L" for adding a list (e.g. k1 += [v1 v2])
- "?=S" for conditional assigning a string (e.g. k1 ?= v1)
- "?=L" for conditional assigning a list (e.g. k1 ?= [v1 v2])
- "SECT_CH" for section change
- "FILE" for file inclusion

Callback with SECT_CH operation is called after the section is changed with
one of:
- [SECT_NAME]
- SECT_NAME {
- }

key name argument in this case is a current section name.

Callback with FILE operation is called for every file (if a file name pattern
match more than one file) before file inclusion.

A key full name is a list with a sect name and a key name. E.g.
if we inside the section "s2", which inside the section "s1" (i.e. the
current section full name is {s1 s2}), and the key name is "n1.n2" and
-hd is ".", then key full name is {s1 s2 n1 n2}.


RATIONALE
=========

Due to shimmering in tcl we can't reliably determine the type of a value in
a parsed conf if we return just the dict from the parser. For example,
we expect the next conf:

n1 = VALUE

But a user mistakenly(due to copy-pasting or something else) made n1 a
section:

n1 {
  n2 = VALUE
}

After parsing with any of load proc we will have the next parsed conf:

n1 {n2 VALUE}

Which from our perspective has key n1 with value "n2 VALUE". If we do no
acrobatics with ::tcl::unsupported::representation (it is unsupported,
isn't it :-)?), then we can't differentiate n1 key with value "n2 VALUE" from
{n1 n2} key with value "VALUE".

To solve this problem we should get somehow types of values. And here we have
2 possible solutions:

1. return some dict with values types (sect/key) in addition to dict
   with key-values
2. use callback that called on every key-value pair (and thus we can clearly
   distinguish between section and key, because at that point we have the
   exact information about what is it)

The first method is used in previous versions of conf package. The dict of
values types - specification - was difficult to work with. And there was
troubles to work with confs with not constant struct - e.g. a simple
key-value can be replaced with extended section-values by a user:

k1 = v1

or

k1 {
  k1_sub1 = v1
  k1_sub2 = v2
}

The second method is used in the current version of conf package. Although
this method is more verbose compared to the first one (in some cases, where
we need a small spec or need no spec at all), it is more understandable and
more userfriendly. Also, we can do many interesting things with a callback,
like a checking key/section redefinition or key/section case insensitivity.


Examples
========

The next callback is used for the all examples below:

proc conf_cb {_conf _ctx op kname kval} {
        upvar #0 $_conf conf

        if {($op ne "SECT_CH") && ($op ne "FILE")} {
                dict set conf {*}$kname $kval
        }
}

Simple conf
-----------

k1=v1
k2="val
with
many
lines"
k3 =
	"val with \" inside"
k4 = [
	[many values]
	[inside list]
	[for one key]]

loaded with `load_from_file {conf_cb conf} my.conf` give a conf:

k1 v1 k2 {val
with
many
lines} k3 {val with " inside} k4 {{many values} {inside list} {for one key}}

Conf with sections
------------------

k1 = v1
[g1]
k2 = v2
[g2]
k3 = v3

loaded with `load_from_file {conf_cb conf} my.conf` give a conf:

k1 v1 g1 {k2 v2} g2 {k3 v3}

Conf with nested sections
-------------------------

k1 = v1
g1 {
  k2 = v2
  g2 {
    k3 = v3
  }
}

loaded with `load_from_file {conf_cb conf} my.conf` give a conf:

k1 v1 g1 {k2 v2 g2 {k3 v3}}

Conf with hierarchy delimiter specified
---------------------------------------

g1.k1 = [1 2 3 [4 5]]
g2.k2 = v2

loaded with `load_from_file -hd . {conf_cb conf} my.conf` give a conf:

g1 {k1 {1 2 3 {4 5}}} g2 {k2 v2}

Conf monster
------------

g1.k1 = [1 2 3 [4 5]]
[g2]
k2 = v2
k3.k4 = v3
[g2.g3]
k4 = v4
g4.g5 {
  k5.k6 = v6
  [g7.g8]
  k7.k8 = v7
}

loaded with `load_from_file -hd . {conf_cb conf} my.conf` give a conf:

g1 {k1 {1 2 3 {4 5}}} g2 {k2 v2 k3 {k4 v3} g3 {k4 v4}} g4 {g5 {k5 {k6 v6} g7 {g8 {k7 {k8 v7}}}}}

Conf with comments
------------------

# here is some comments
k = v
k1 = v1 # another comments
k2 = v2
k3 = # this is k3
        v3 # this is k3 value
k4 = "v4 with # inside"
# end of file

loaded with `load_from_file -hd . {conf_cb conf} my.conf` give a conf:

k v k1 v1 k2 v2 k3 v3 k4 {v4 with # inside}

See ex*.tcl for examples of code:

- ex1.tcl - just print callback parameters
- ex2.tcl - very simple callback that skip SECT_CH and FILE op and
            treat += and ?= op as = and in all these cases simply assign
            a value to a key
- ex3.tcl - ex2.tcl + overwrite checking
- ex4.sh  - conf_get.tcl use from a shell script
- ex5.tcl - real config reading example


Errors
======

conf error at m.conf:1: Unexpected token sequence: "'k2'#6(L1) '='#1(L1) '{'#2(L1)". Want: KEY = VAL or KEY = [ or GROUP_NAME { or } or [GROUP_NAME]

	There is parser error for token sequence started at line 1.
	First token is 'k2' with token code 6 at line 1(L1),
	second token is '=' with token code 1 at line 1,
	third token is '{' with token code 2 at line 1. i.e.:

	k2 = {

conf error at m.conf:1: Unexpected token sequence: "'k2'#6(L1) 'v2'#6(L1)". Want: KEY = VAL or KEY = [ or GROUP_NAME { or } or [GROUP_NAME]

	Key with word instead of '=' or section with word instead of '{':

	k2 v2

conf error at m.conf:1: Possible unclosed quotes at line 1. Unexpected token sequence: "'k2'#6(L1) '='#1(L1)". Want: KEY = VAL or KEY = [ or GROUP_NAME { or } or [GROUP_NAME]

	Double quotes is opened, but is not closed. E.g.:

	k2 = "v2


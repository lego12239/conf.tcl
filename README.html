<!DOCTYPE html>
<html lang="ru">
<head>
  <title>conf package manual</title>
  <style type="text/css">
    .var {
      font-family: monospace;
      font-style: italic;
    }
    .optmark {
      font-family: monospace;
      color: #009d20;
    }
    .optname {
      font-family: monospace;
      font-weight: bold;
    }
    .cmdname {
      font-family: monospace;
      font-weight: bold;
    }
    pre {
	    background-color: #f2f2f2;
	}
  </style>
</head>
<body>
<h1>Conf package</h1>

<h2>Overview</h2>

<p>
conf package is pure-tcl package for loading a textual configuration data
from file, channels and strings.
It supports conf syntax with hierarchical and
ini-style sections and key-value pairs where value can be string or list.
The features are:
</p>

<ul>
  <li>conf syntax: hierarchical sections support</li>
  <li>conf syntax: ini-style sections support</li>
  <li>conf syntax: comments support</li>
  <li>conf syntax: file inclusion support</li>
  <li>
    callback based parsing: callback is called on every key-value assignment,
    section change and file inclusion
  </li>
</ul>

<p>
conf package contains 3 main routines for text configuration file loading:

<ul>
  <li>
    <code>conf::load_from_file</code> &ndash; to load a conf from a file
  </li>
  <li>
    <code>conf::load_from_fh</code> &ndash; to load a conf from an open file handler
  </li>
  <li>
    <code>conf::load_from_str</code> &ndash; to load a conf from a string
  </li>
</ul>
</p>

<p>
And the next utility routines:

<ul>
  <li>
    <code>conf::escape_value</code> &ndash; escape a specified value
    according to conf syntax rules
  </li>
</ul>

<h2>Contents</h2>

<ul>
  <li><a href="#synopsis">Synopsis</a></li>
  <li><a href="#description">Description</a></li>
  <li><a href="#conf_syntax">Conf syntax</a></li>
  <li><a href="#conf_syntax_abnf">Conf syntax ABNF</a></li>
  <li><a href="#callback">Callback</a></li>
  <li><a href="#rationale">Rationale</a></li>
  <li><a href="#ex">Examples</a></li>
  <li><a href="#errors">Errors</a></li>
</ul>

<h2><a name="synopsis">Synopsis</a></h2>

<div>
  <code>
    <span class="cmdname">load_from_file</span>
    <span class="optmark">?</span><span class="optname">-hd</span>
    <span class="var">STR</span><span class="optmark">?</span>

    <span class="optmark">?</span><span class="optname">-path</span>
    <span class="var">STR</span><span class="optmark">?</span>

    <span class="var">CALLBACK</span>
    <span class="var">FILE_NAME</span>
  </code>
</div>
<div>
  <code>
    <span class="cmdname">load_from_fh</span>
    <span class="optmark">?</span><span class="optname">-hd</span>
    <span class="var">STR</span><span class="optmark">?</span>

    <span class="optmark">?</span><span class="optname">-path</span>
    <span class="var">STR</span><span class="optmark">?</span>

    <span class="var">CALLBACK</span>
    <span class="var">CHAN</span>
  </code>
</div>
<div>
  <code>
    <span class="cmdname">load_from_str</span>
    <span class="optmark">?</span><span class="optname">-hd</span>
    <span class="var">STR</span><span class="optmark">?</span>

    <span class="optmark">?</span><span class="optname">-path</span>
    <span class="var">STR</span><span class="optmark">?</span>

    <span class="optmark">?</span><span class="optname">-s</span>
    <span class="var">START_INDEX</span><span class="optmark">?</span>

    <span class="optmark">?</span><span class="optname">-e</span>
    <span class="var">END_INDEX</span><span class="optmark">?</span>

    <span class="var">CALLBACK</span>
    <span class="var">CONF_STR</span>
  </code>
</div>
<div>
  <code>
    <span class="cmdname">escape_value</span>
    <span class="var">VALUE</span>
  </code>
</div>

<h2><a name="description">Description</a></h2>

<p>
<span class="cmdname">load_from_file</span> command parse a specified file and calls a specified callback
  on every parsed key-value, section start/end and file inclusion.
  This command accepts the next options:
</p>

<dl>
  <dt><span class="optname">-hd</span> <span class="var">STR</span></dt>
  <dd>
    use <span class="var">STR</span> as hierarchy delimiter in key
    names and group names.
    <br/>
    By default, there is no hierarchy delimiter.
  </dd>
  <dt>
    <span class="optname">-path</span>
    <span class="var">STR</span>
  </dt>
  <dd>
    use <span class="var">STR</span> as file path prefix for every
    included file.
    <br/>
    By default, "./".
  </dd>
</dl>

And 2 mandatory arguments:
<dl>
  <dt>CALLBACK</dt>
  <dd>
      CALLBACK is a proc name or a list - {CALLBACK ARG1 ...}. This callback
      is called on every parsed key-value, section enter/leave and
      file inclusion.
  </dd>
  <dt>FILE</dt>
  <dd>
    A file name to parse.
  </dd>
</dl>

<p>
<span class="cmdname">load_from_fh</span> works like a
<span class="cmdname">load_from_file</span> proc and accepts the same options,
  but parse a data from a specified file handle(chan) instead of file
  specified by a name.
</p>

<p>
<span class="cmdname">load_from_str</span> command parse a data from a
specified string and calls a specified callback like a
<span class="cmdname">load_from_file</span> proc.
Options are the same as for <span class="cmdname">load_from_file</span>
with addition of:
</p>
<dl>
  <dt>
    <span class="optname">-s</span>
    <span class="var">START_INDEX</span>
  </dt>
  <dd>
    start parsing of a string from specified position(in chars)
  </dd>
  <dt>
    <span class="optname">-e</span>
    <span class="var">END_INDEX</span>
  </dt>
  <dd>
    end parsing of a string at specified position(in chars);
    this will be the last character we read
  </dd>
</dl>

<p>
<span class="cmdname">escape_value</span> command returns an escaped
form(according to conf syntax rules) of specified value.
</p>


<h2><a name="conf_syntax">Conf syntax</a></h2>

<p>
Conf consists from key-value pairs,
which can be grouped in sections.
Whitespaces are ignored.
Comment can be started by <code>#</code> symbols at almost any
place(excluding <code>#</code> inside a quoted string) and lasts until
the end of the line.
Key, value and section name can consist of any chars exclude any space
chars, <code>'='</code>, <code>'#'</code>, <code>'"'</code>,
<code>'['</code>, <code>']'</code>, <code>'{'</code>, <code>'}'</code>,
<code>'+'</code>, <code>'?'</code>.
If a key, value or section name contains any of these characters,
then the entire key,
value or section name must be enclosed in double quotes.
In this case, if double quotes appears inside the value,
it must be escaped with a backslash(<code>\</code>).
Value can be a string(quoted or not) or a list.
A list is started with <code>'['</code> and is ended with <code>']'</code>.
List elements are separated with spaces.
Each element of a list is a string or a list.
</p>

Key, section and file inclusion must start on new line.

<h3>Assignment</h3>

Assignment a string to a key:

<pre>
k1 = some_word
k2 = "some string \"with\" spaces"
</pre>

Assignment a list to a key:

<pre>
k1 = [v1 v2 v3]
k2 = [v1 "some string \"with\" spaces" v2]
</pre>

Assignment a list of lists to a key:

<pre>
k3 = [[v1 v2] [v3 v4] [v5 v6]]
</pre>

Also, ?= and += can be used for assignment:

<pre>
k1 ?= some_word
k2 ?= [v1 v2]

k3 = v1
k3 += some_word
k3 += [v2 v3]
</pre>

?= can be used to assign a value only if this key isn't defined yet.
And += can be used to append a value to existent one.

<h3>File including</h3>

Conf file can include another conf files with syntax:

<pre>
< FILENAME
</pre>

Where FILENAME is glob pattern.
Files are parsed in alphabetical order.

<h3>Sections</h3>

A section can be defined in two ways. With [] syntax:

<pre>
[SECT_NAME]
</pre>

Or with {} syntax:

<pre>
SECT_NAME {
}
</pre>

If a section is defined with <code>`[SECT_NAME]`</code> syntax,
then current section prefix(top of a section prefixes stack) is replaced
with <code>SECT_NAME</code>.
If a section is defined with <code>`SECT_NAME {`</code> syntax,
then <code>SECT_NAME</code> section prefix is pushed to a section prefixes
stack and becomes a current section prefix until we reach
corresponding "<code>}</code>",
in which case <code>SECT_NAME</code> is poped from a section prefixes
stack and previous value becomes a top of a stack
and a current section prefix.
In other words, []-sections is not stacked and is replaced by both
[]-section and {}-section that come after it;
{}-sections is stacked and both []-section and {}-section coming
after is appended to it.
E.g. if we call any of load proc with "-hd .",
then this confs are equal:

variant 1:

<pre>
sect1.sect2.key1 = val1
sect1.sect2.key2 = val2
sect1.sect2.sect3.key3 = val3
sect1.sect2.key4 = val4
</pre>

variant 2:

<pre>
[sect1.sect2]
key1 = val1
key2 = val2
sect3.key3 = val3
key4 = val4
</pre>

variant 3:

<pre>
[sect1.sect2]
key1 = val1
key2 = val2
[sect1.sect2.sect3]
key3 = val3
[sect1.sect2]
key4 = val4
</pre>

variant 4:

<pre>
sect1.sect2 {
	key1 = val1
	key2 = val2
	sect3 {
		key3 = val3
	}
	key4 = val4
}
</pre>

variant 5:

<pre>
sect1.sect2 {
	key1 = val1
	key2 = val2
	key4 = val4
	[sect3]
	key3 = val3
}
</pre>

<h2><a name="conf_syntax_abnf">Conf syntax ABNF</a></h2>

<pre>
conf = (key-value / section / include-stmt / WSP0)
       *(NL (key-value / section / include-stmt / WSP0))
key-value = key ("=" / "+=" / "?=") (value / list)
key = word / str
value = word / str
list = WSP0 "[" *((word / str / list) WSP) "]"
section = ("[" (word / str) "]" *conf) /
        ((word / str) "{" *conf "}")
include-stmt = "<" WSP0 (word / str)
word = WSP0 (%d33 / %d36-60 / %d62-90 / %d92 / %d94-122 / %d124 / %d126 - %d255) WSP0
        ; all except WSP, =, #, ",
        ; +, ?, [, ], {, }
str = WSP0 DQUOTE (%d01-d91 / %93-d255 / %d92 %d92 / %d92 DQUOTE) DQUOTE WSP0
        ; any chars in double quotes, where double quotes inside string
        ; can be escaped with \ char
WSP0 = *WSP
WSP = SP / HTAB / NL
NL = CR / LF / CRLF
</pre>

<h2><a name="callback">Callback</a></h2>

<p>
Callback is a proc name or a list with proc name and args like
{PROC ARG1 ARG2 ...}. This callback is called on every parsed key-value,
section enter/leave and file inclusion. It is called with specified arguments
and appended context variable name, the operation, a full key name, a value.
E.g. if callback is specified as {cb_proc privvar}, then callback must be
define as:
</p>
<pre>
proc cb_proc {privvarname _ctx op kname kval} {
	upvar #0 $privvarname privvar
	upvar $_ctx ctx

...
}
</pre>

Callback last parameters must be:
<ul>
  <li>ctx var name (parser internal structure, mostly you needn't it)</li>
  <li>
    operation (<code>=S</code>, <code>=L</code>, <code>+=S</code>,
    <code>+=L</code>, <code>?=S</code> or <code>?=L</code>,
    <code>SECT_CH</code>, <code>FILE</code>)
  </li>
  <li>key full name (list with a sect name and a key name)</li>
  <li>value</li>
</ul>

Where operation is:
<ul>
  <li>"<code>=S</code>" for assigning a string (e.g. k1 = v1)</li>
  <li>"<code>=L</code>" for assigning a list (e.g. k1 = [v1 v2])</li>
  <li>"<code>+=S</code>" for adding a string (e.g. k1 += v1)</li>
  <li>"<code>+=L</code>" for adding a list (e.g. k1 += [v1 v2])</li>
  <li>"<code>?=S</code>" for conditional assigning a string (e.g. k1 ?= v1)</li>
  <li>"<code>?=L</code>" for conditional assigning a list (e.g. k1 ?= [v1 v2])</li>
  <li>"<code>SECT_CH</code>" for section change</li>
  <li>"<code>FILE</code>" for file inclusion</li>
</ul>


Callback with SECT_CH operation is called after the section is changed with
one of:
<ul>
  <li>[SECT_NAME]</li>
  <li>SECT_NAME {</li>
  <li>}</li>
</ul>

key name argument in this case is a current section name.

Callback with FILE operation is called for every file (if a file name pattern
match more than one file) before file inclusion.

A key full name is a list with a sect name and a key name. E.g.
if we inside the section "s2", which inside the section "s1" (i.e. the
current section full name is {s1 s2}), and the key name is "n1.n2" and
-hd is ".", then key full name is {s1 s2 n1 n2}.


<h2><a name="rationale">Rationale</a></h2>

<p>
Due to shimmering in tcl we can't reliably determine the type of a value in
a parsed conf if we return just the dict from the parser. For example,
we expect the next conf:
</p>

<pre>
n1 = VALUE
</pre>

But a user mistakenly(due to copy-pasting or something else) made n1 a
section:

<pre>
n1 {
  n2 = VALUE
}
</pre>

After parsing with any of load proc we will have the next parsed conf:

<pre>
n1 {n2 VALUE}
</pre>

<p>
Which from our perspective has key <code>n1</code> with value
"<code>n2 VALUE</code>".
If we do no acrobatics with <code>::tcl::unsupported::representation</code>
(it is unsupported, isn't it :-)?),
then we can't differentiate n1 key with value "n2 VALUE" from
{n1 n2} key with value "VALUE".

To solve this problem we should get somehow types of values. And here we have
2 possible solutions:

<ol>
  <li>
    return some dict with values types (sect/key) in addition to dict
    with key-values
  </li>
  <li>
    use callback that called on every key-value pair (and thus we can clearly
    distinguish between section and key, because at that point we have the
    exact information about what is it)
  </li>
</ol>

The first method is used in previous versions of conf package. The dict of
values types - specification - was difficult to work with. And there was
troubles to work with confs with not constant struct - e.g. a simple
key-value can be replaced with extended section-values by a user:

<pre>
k1 = v1
</pre>

or

<pre>
k1 {
  k1_sub1 = v1
  k1_sub2 = v2
}
</pre>

The second method is used in the current version of conf package. Although
this method is more verbose compared to the first one (in some cases, where
we need a small spec or need no spec at all), it is more understandable and
more userfriendly. Also, we can do many interesting things with a callback,
like a checking key/section redefinition or key/section case insensitivity.


<h2><a name="ex">Examples</a></h2>

The next callback is used for the all examples below:

<pre>
proc conf_cb {_conf _ctx op kname kval} {
        upvar #0 $_conf conf

        if {($op ne "SECT_CH") && ($op ne "FILE")} {
                dict set conf {*}$kname $kval
        }
}
</pre>

<h3>Simple conf</h3>

<pre>
k1=v1
k2="val
with
many
lines"
k3 =
	"val with \" inside"
k4 = [
	[many values]
	[inside list]
	[for one key]]
</pre>

loaded with <code>`load_from_file {conf_cb conf} my.conf`</code> give a conf:

<pre>
k1 v1 k2 {val
with
many
lines} k3 {val with " inside} k4 {{many values} {inside list} {for one key}}
</pre>

<h3>Conf with sections</h3>

<pre>
k1 = v1
[g1]
k2 = v2
[g2]
k3 = v3
</pre>

loaded with <code>`load_from_file {conf_cb conf} my.conf`</code> give a conf:

<pre>
k1 v1 g1 {k2 v2} g2 {k3 v3}
</pre>

<h3>Conf with nested sections</h3>

<pre>
k1 = v1
g1 {
  k2 = v2
  g2 {
    k3 = v3
  }
}
</pre>

loaded with <code>`load_from_file {conf_cb conf} my.conf`</code> give a conf:

<pre>
k1 v1 g1 {k2 v2 g2 {k3 v3}}
</pre>

<h3>Conf with hierarchy delimiter specified</h3>

<pre>
g1.k1 = [1 2 3 [4 5]]
g2.k2 = v2
</pre>

loaded with <code>`load_from_file -hd . {conf_cb conf} my.conf`</code> give a conf:

<pre>
g1 {k1 {1 2 3 {4 5}}} g2 {k2 v2}
</pre>

<h3>Conf monster</h3>

<pre>
g1.k1 = [1 2 3 [4 5]]
[g2]
k2 = v2
k3.k4 = v3
[g2.g3]
k4 = v4
g4.g5 {
  k5.k6 = v6
  [g7.g8]
  k7.k8 = v7
}
</pre>

loaded with <code>`load_from_file -hd . {conf_cb conf} my.conf`</code> give a conf:

<pre>
g1 {k1 {1 2 3 {4 5}}} g2 {k2 v2 k3 {k4 v3} g3 {k4 v4}} g4 {g5 {k5 {k6 v6} g7 {g8 {k7 {k8 v7}}}}}
</pre>

<h3>Conf with comments</h3>

<pre>
# here is some comments
k = v
k1 = v1 # another comments
k2 = v2
k3 = # this is k3
        v3 # this is k3 value
k4 = "v4 with # inside"
# end of file
</pre>

loaded with <code>`load_from_file -hd . {conf_cb conf} my.conf`</code> give a conf:

<pre>
k v k1 v1 k2 v2 k3 v3 k4 {v4 with # inside}
</pre>

See ex*.tcl for examples of code:
<ul>
  <li>ex1.tcl - just print callback parameters</li>
  <li>ex2.tcl - very simple callback that skip SECT_CH and FILE op and
            treat += and ?= op as = and in all these cases simply assign
            a value to a key
  </li>
  <li>ex3.tcl - ex2.tcl + overwrite checking</li>
  <li>ex4.sh  - conf_get.tcl use from a shell script</li>
  <li>ex5.tcl - real config reading example</li>
</ul>


<h2><a name="errors">Errors</a></h2>

<dl>
  <dt>
<pre>
conf error at m.conf:1: Unexpected token sequence: "'k2'#6(L1) '='#1(L1) '{'#2(L1)". Want: KEY = VAL or KEY = [ or GROUP_NAME { or } or [GROUP_NAME]
</pre>
  </dt>
  <dd>
	There is parser error for token sequence started at line 1.
	First token is 'k2' with token code 6 at line 1(L1),
	second token is '=' with token code 1 at line 1,
	third token is '{' with token code 2 at line 1. i.e.:

<pre>
k2 = {
</pre>
  </dd>
  <dt>
<pre>
conf error at m.conf:1: unexpected token sequence: "'k2'#6(L1) 'v2'#6(L1)". Want: KEY = VAL or KEY = [ or GROUP_NAME { or } or [GROUP_NAME]
</pre>
  </dt>
  <dd>
    Key with word instead of '=' or section with word instead of '{':

<pre>
k2 v2
</pre>
  </dd>
  <dt>
<pre>
conf error at m.conf:1: Possible unclosed quotes at line 1. unexpected token sequence: "'k2'#6(L1) '='#1(L1)". Want: KEY = VAL or KEY = [ or GROUP_NAME { or } or [GROUP_NAME]
</pre>
  </dt>
  <dd>
	Double quotes is opened, but is not closed. E.g.:

<pre>
k2 = "v2
</pre>
  </dd>
</dl>
</body>
</html>
